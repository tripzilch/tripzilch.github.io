# Interesting basic PRNG distributions

_by Piter Pasma_

Have you ever needed a value from a random range, but you don't want a lot of high numbers? In this article, we'll investigate these, and other basic transformations of PRNG outputs.

The formula for a random range is `lo + R() * (hi - lo)`, where `R()` is our PRNG, returning a random value between 0 and 1 (note that in some examples below, we may also use `R(a)`, returning a random value between 0 and `a`). 

In order to skew our random range to have (e.g.) less probability for high numbers, we need to skew the result of `R()` to have more probability for numbers close to 0 and less for numbers close to 1.

There are all sorts of fun formulas that transform a value between 0 and 1 into another value between 0 and 1. Such formulas are often called [easing functions](https://www.google.com/search?hl=en&q=easing+functions), and are useful for finetuning the speed of animations, among other things. We can use easing functions to transform our PRNG as well (and I recommend you to try all of them), but the possibilities are in fact broader, because we can also combine the results of several calls to `R()`.

We're going to use my tool the [RANDOMOMETER](https://randomometer.netlify.app) to investigate the probability distributions generated by different formulas. The RANDOMOMETER allows you to specify the body of a Javascript function that returns a random value. When you hit ctrl-enter, it will evaluate this function many times (default is 1e6 = 1000000 times) and then draw a frequency histogram of the outputs, allowing you to see the probability distribution.

**You can click on any of the formulas below to view their histograms in the RANDOMOMETER.** 

_(I may add screenshots in the future, but I really want to invite you to click the links and have a play with the live formulas)_

## Transforming a PRNG to have less high numbers

One way to do this, is to take the minimum of two random numbers:

[`min(R(), R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+min%28R%28%29%2C+R%28%29%29)

Another way to get exactly (!!) the same distribution is this formula:

[`1 - sqrt(R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+1-R%28%29**.5)

I think it's interesting and fun that there are quite different formulas yielding the same distribution. Here is yet another way:

[`abs(R() - R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+abs%28R%28%29-R%28%29%29)

So this is pretty cool. But as you can see from the histograms, these formulas are perhaps a little bit _too_ skewed. The probability to return 1 goes all the way to zero (and therefore so would the probability to return the highest value in our range). What if you want something a little bit less extreme?

We can modify the first of the three formulas above, for instance like this:

[`min(R(), R(3))`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+min%28R%28%29%2CR%283%29%29)

This histogram seems to have about 50% probability to return 1. Try playing with the number `3` in the above code, to see how it changes the distributions. Higher values will make it more flat, whereas lower values make the probability to return 1 smaller. Note that using values less than 1 breaks the distribution a bit because it won't return all numbers between 0 and 1 anymore. 

There's probably a formula to calculate the required value, given a certain probability to return 1, but I haven't quite worked it out yet. Either way, for most of my purposes it's enough to visually estimate from the histogram by trying a few different values.

## Transforming a PRNG to have less low numbers

First of, we can simply do `1 - <any of the formulas above>`, because doing one minus something inverts the range. But we can also start out by taking the maximum of two random numbers:

[`max(R(), R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+max%28R%28%29%2CR%28%29%29)

And then we can do a similar modification of the formula to make it less extreme:

[`max(1 - R(3), R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+max%281-R%283%29%2CR%28%29%29)

Note that it's not quite a "mirror" of the `min` variant. So depending on your tastes for which formula looks more pretty, you might consider inverting the range instead:

[`1 - min(R(3), R())`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+1-min%28R%283%29%2CR%28%29%29)

It's actually quite easy to see that the last two formulas are equivalent, taking the "one minus" outside of the `min`, and because `R()` is the same as `1 - R()` (because it's the uniform distribution).

I think it's super interesting that `max(R(), R())` is equivalent to doing `sqrt(R())`, and I wonder if playing around with this idea might in certain other situations allow us to avoid a `sqrt` function, which may be more expensive than generating two random numbers.

## Triangular and Normal distributions

Subtracting two random numbers from each other gives a triangular distribution centred around 0:

[`R() - R()`](https://randomometer.netlify.app/?lo=-1&hi=1&bins=150&code=return+R%28%29-R%28%29)

Note that the range of this histogram goes from -1 to 1. The triangle distribution is the first order (linear) approximation to the normal (or Gaussian) distribution. I use this distribution very often, scaling and adding it to a value when I want to tweak or jitter a variable around this value, with less probability for being further away from it.

In general I find the triangle distribution to suffice for almost all of my normal(-ish) distribution needs. But in case you want a higher order approximation, you can try these formulas:

[`R() - R() + R() - .5`](https://randomometer.netlify.app/?lo=-1.5&hi=1.5&bins=150&code=return+R%28%29+-+R%28%29+%2B+R%28%29+-+.5) 

[`R() - R() + R() - R()`](https://randomometer.netlify.app/?lo=-2&hi=2&bins=150&code=return+R%28%29+-+R%28%29+%2B+R%28%29+-+R%28%29)

Note that the range of these histograms are -1.5 to 1.5 and -2 to 2, respectively. I'm not exactly sure what their standard deviations are.

If you need an _even better_ approximation to the normal distribution, you could keep adding and subtracting more and more random numbers, and this would work. I think it converges pretty quickly actually. However, at some point generating that many random numbers probably gets less efficient than doing the [Box-Muller transform](https://en.wikipedia.org/wiki/Box%E2%80%93Muller_transform) (which actually gets you two independent normally distributed values at once).

## Other fun stuff

One of the most basic easing functions is `x * x`, squaring a number between 0 and 1 always yields another number between 0 and 1. Trying this in our RANDOMOMETER looks like this:

[`R()**2`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+R%28%29**2)

Note that the probability distribution is really steep, yet doesn't reach a probability of 0 at one.

Instead of squaring one random number, we can also multiply two different random numbers. If you think about it, this is not quite the same, but what does the histogram look like?

[`R() * R()`](https://randomometer.netlify.app/?lo=0&hi=1&bins=150&code=return+R%28%29*R%28%29)

This probability distribution is still steeper than say, `min(R(), R()`, but not quite as steep as `R()**2`. Also note that unlike the previous it does have a probability of 0 at one. When I need a steep distribution, this is the one I usually reach for.

## Experiment!

You can combine the above ideas in all sorts of fun ways to generate even more different probability distributions.

What would happen if you raised `R()` to different powers?

Or if you took the minimum of three random numbers? Or the maximum? What about taking the middle one?

Please experiment and do let me know if you find anything cool!

## Related links

Maybe I'll add more related links, but I wanted to link this one article which is super cool in case you ever need to generate uniform points on a sphere, inside a ball or a disc, on or in any N-dimensional sphere or ball. Even if you think you know how to do this, it might list a couple of methods you haven't heard about, so check it out in case this interests you:

[How to generate uniformly random points on n-spheres and in n-balls](https://extremelearning.com.au/how-to-generate-uniformly-random-points-on-n-spheres-and-n-balls/)


